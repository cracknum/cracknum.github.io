[{"title":"Convex Hull","url":"/2025/05/25/Computational%20Geometry/Convex%20Hull/","content":"一、凸性质 (Convexity)1. 引入\n颜色混合我们可以使用几种只包含R，G的颜色来进行混合从而得到第三种颜色，但是第三种颜色是否可以用这几种颜色勾兑，我们只有从数学上进行尝试，下面我们使用代码进行处理。\n\ndef cal_porp_two(color1, color2, resultColor):    for i in range(1, 10):        for j in range(1, 10):            if ((color1[0] * i + color2[0] * j) % resultColor[0] == 0 and                (color1[1] * i + color2[1] * j) % resultColor[1] == 0):                print(\"two kind of colors mix proportion: color1\", i, \", color2: \", j)def cal_porp_three(color1, color2, color3, resultColor):    for i in range(1, 10):        for j in range(1, 10):            for k in range(1, 10):                mixed_color = tuple(map(lambda color1_i, color2_i, color3_i: i * color1_i + j * color2_i + k * color3_i, color1, color2, color3))                if (mixed_color[0] % resultColor[0] == 0 and                    mixed_color[1] % resultColor[1] == 0):                    print(\"three kind of colors mix proportion: color1\", i, \", color2: \", j, \", color3: \", k)if __name__ == \"__main__\":    color1 = (10, 35)    color2 = (16, 20)    color3 = (7, 15)    result_color = (12, 30)    cal_porp_two(color1, color2, result_color)    cal_porp_three(color1, color2, color3, (13, 22))\n也即是通过穷举混合比例来进行判断我们是否可以通过混合得到第三种颜色，从代码也可以看出这种方法的时间复杂度是非常高的，三种的时间复杂度为，如果要是4种、5种甚至更多呢？\n接下来我们可以通过几何的方式来对数据进行解释，来尝试降低时间复杂度\n\n几何解释 (颜色空间)\n\n将上述的颜色转换为几何上的坐标，从图上可以看出对于使用两种颜色就可以勾兑出第三种颜色的情况，在几何上第三种颜色必定会在两种颜色之间；对于需要使用三种颜色才能勾兑出的颜色那么勾兑出的颜色也必须在三种颜色组成的三角形内部或者三角形的边上。\n通过上述转换，我们就将从三种颜色的随意组合问题转换为了线性问题也就是判断需要勾兑的颜色是否在三角形的内部，就可以得知需要的颜色是否可以被勾兑出来。\n另外，我们知道并非每一种颜色都有资格作为颜色空间的”基颜色”而存在的，这个就像我们在笛卡尔坐标系中的解释是一样的，在二维笛卡尔坐标系中的每个点都可以使用两个基向量进行“勾兑”出来，所以在这个颜色混合的问题中我们也要提取出“基颜色”。从笛卡尔坐标系中我们得知基向量都是相互垂直不存在相关关系的一组向量而构成的，所以这里的“基颜色”也是互不相关，也即无法通过组合而得到的颜色而构成的，在凸问题中我们称这种“基颜色”为凸无关，而能够被组合出来的颜色所代表的点我们称之为凸相关。\n\n凸组合 (Covex Combination)\n\n这里给出了凸组合的概念。凸组合需要满足两个条件\n\n组合系数需要大于等于0\n组合系数之和等于1\n\n这里无需给出更多的解释，从几何解释中我们就可以理解为什么这样定义。\n凸相关的点其实并不被我们在凸的性质中需要，从几何解释中我们可以看到这些点被包裹在凸的内部并不会对我们处理问题给出任何的优势。\n二、极点 (Extreme Points)1. 什么是极点极点从字面理解也就是一些在边界或者不再有其他点在其前面的点，称为极点。\n给出一个形式上的定义\n\n2. 如何判断极点一个点是否是极点，从形式上理解就是判断这个点是否在两侧都有点，如果都有点，那么这个点就不是极点，因为没有“极性”。\n如何判断一个点是否是极点呢？这就需要结合前面我们定义的“凸”的概念了，我们把所有不可被其他点通过各种插值组合出来的点成为凸无关的点，我们把空间用基本图元三角形进行分割，每个三角形将空间分为七份\n\n如果一个点的坐标可以被组合出来，那么这个点就不是极点，结合凸无关的定义我们可以得知，如果一个点落到了一个三角形的内部或者是边上，那么这个点的坐标就是可以组合出来的，比如上图的7，如果不落在三角形的边上和内部而是落在其他的位置例如上图的1~6，那么就是无法被组合出来的，这个也可以通过插值的定义去理解。\n如果判断点无法落在给定的任意一个三角形的内部则这个点就是极点。\n2.1 In-Triangle Test三角形测试用于判定一个点在三角形内部还是三角形外部，三角形测试又可被拆分为点相对应于边的位置的测试。如果一个点在三角形的外部那么这个点一定落在三角形三条边所在直线的同一侧，这是一个充要条件，从下图也可以判断出，除了点7以外，其他点相对于三条边一定在同一侧，反之也对。这样理解下来我们首先将整个点集的测试分割为多个三角形的测试再分割为多条边的测试，这就是分治的思想。\n\n接下来，我们将三角形的三个顶点进行逆时针排列或者顺时针排列定义为：A,B,C，待测试点定义为E，我们分别测试E点相对于边AB，边BC,边CA的位置，这个测试叫做to left测试。\n我们对于to left测试用的方法是计算由E和三角形的任意两个顶点组成的三角形的有向面积，在这里有一个条件就是三角形的顶点一定要按顺时针或者逆时针和待测试点组成三角形，不然有向面积的方向也不一致。\n\n这里有个小的tip，就是这个行列式的推导方式，我看到了一种比较简单的推导方式与大家共享，我们有一个小前提就是要知道两个向量的叉乘的意义：向量的叉乘求的就是两个向量形成的平行四边形的面积\n\n其中为垂直于和所在平面的法向单位向量，方向由右手定则给出。\n对应到平行四边形面积计算公式为底高\n所以，而由、和构成的三角形面积为S的一半。\n上述方式是从向量的角度给出的计算方式，还有另外一种从行列式角度给出的叉乘的定义:\n\n\n定义(逆时针向量)\n\n\n\n\n\n\n从这个方面推出了行列式的形式，不过是凑出来的，但是好记。\n这里还有一个我写的一个随机生成的点的三角形测试，但是没有做优化\n三、极边 (Extreme Edges)在极点的判别算法中，我们先对除了当前点以外的点构造三角形，然后将这个点结合所有三角形进行判别当前点是否为极点，这样我们的时间复杂度为, 在这个构造过程中我们发现，我们判别的过程的最小子问题是判别点和边的关系，判别点是否在三角形的三条边的同侧，如果是则为极点。我们现在反过来想，如果我们现有一条边，然后判别其余的顶点是否在这条边的同一侧是否也能达到相同的目的呢？是的，那这样我们就可以将先构造三角形在判断点是否在三角形三条边的同侧的问题又变为了判断剩余顶点是否在一条边的一边，如果除了当前边的两个顶点外其他顶点都在这条边的一侧，那这条边就是极边，极边上的点也一定为极点。\n\n相比于三角形测试我们消除了计算量，现在我们先找除了待判断点外的所有的边，然后判读点和所有边的关系，所以我们的时间复杂度变为了，从到多出的计算量去哪了，在三角形的重复的边的判断上，两个相邻的三角形公用一条边，而这条边对于所有点会判断两侧，除了最外侧的极边，其余的边每条都会被判断两次，而这个边的数量就是n-1，所以这个n就出现在这里。\n理解了极点的判断，极边的判断更简单了，我们先选出一个待检测点，然后用剩余的顶点构造所有的边，将顶点集合中的所有点执行这个过程，即可得到极边。\nimport randomimport mathdef calculate_distance(point1, point2):    square_distance = (point1[0] - point2[0])**2 + (point1[1] - point2[1]) ** 2    return math.sqrt(square_distance)# 左侧顶点测试, 测试直线point1--&gt;point2def to_left_test(point1, point2, point3)-&gt; bool:    # 叉积刚好是由两个向量所在的平行四边形面积的两倍    value = point1[0] * (point2[1] - point3[1]) + point2[0] * (point3[1] - point1[1]) + point3[0] * (point1[1] - point2[1])    if value &gt;= 0:        return True    else:        return False'''测试点集和有向线段的关系'''def test_line_points(points, line) -&gt; bool:    side = [False, False]    for point in points:        # 如果点为线段的两个顶点之一则跳过        d1 = calculate_distance(point, line[0])        d2 = calculate_distance(point, line[1])        if  d1 &lt; 1e-6 or d2 &lt; 1e-6:            continue                test_result = to_left_test(line[0], line[1], point)        if False == test_result:            side[0] = True        else:            side[1] = True                # 有点同时出现在了线段的两侧，所以直接返回False，测试失败        if side[0] + side[1] == 2:            return False            return Truex_list = [random.uniform(-10, 10) for i in range(-10, 10)]y_list = [random.uniform(-10, 10) for i in range(-10, 10)]for x, y in zip(x_list, y_list):    print(\"x: \", x, \", y: \", y)import matplotlib.pyplot as plt%matplotlib autoplt.figure(figsize=(8, 8))points = tuple(zip(x_list, y_list))pass_lines = []plt.ion()ims = []for i in range(len(x_list)):    for j in range(i+1, len(x_list)):        plt.clf()        line = \\        [            [x_list[i], y_list[i]],             [x_list[j], y_list[j]]        ]        test_result = test_line_points(points, line)        if True == test_result:            pass_lines.append(line)        test_line_points(points, line)                # 绘制每一次的结果        plt.plot([line[0][0], line[1][0]], [line[0][1], line[1][1]], marker=\"o\")                for line in pass_lines:            xs = [line[0][0], line[1][0]]            ys = [line[0][1], line[1][1]]            plt.plot(xs, ys, marker=\"o\")        for x, y in zip(x_list, y_list):            plt.scatter(x, y, marker=\"o\")                plt.pause(0.1)plt.ioff()plt.show(block=True)\n四、增量构建 (Incremental Construction)1. 构造的粗略过程在使用寻找极边的形式构造凸包的方式，我们需要首先查找所有的可能的边，这个过程需要的时间复杂度为，然后使用每一条边都要去查探非边上的顶点是否在边的同一侧，这个过程中也需要。我们再次反转过来想，如果我们不再已边为主，而是以点为主，判断点是否在凸包之上，这里看似我们回到了已寻找极点的方式构造凸包，在寻找极点的方式构造凸包中，我们需要检查顶点是否在任意的三角形内部，这也是需要构造三角形。\n如果这里我们先构造一个任意的三角形，但是我们不再多次构造这个三角形，一个三角形在初次构造时相对于自己的顶点集合()必定为凸包，我们再将整个顶点集合()中不在三角形内部的顶点置为待测试的顶点()，我们只需要持续的测试中的顶点是否能够满足凸包的要求，如果满足则将顶点插入到中，不断的进行，直到所有中的顶点测试完成则凸包构造完毕。\n2. 测试规则描述\n在构造过程中，我们需要测试中的点是否满足凸包的要求，这个测试过程需要结合我们在极点方式和极边方式构造过程中使用的一些功能，例如to_left_test。我们要求所有的顶点都要逆序排列，这个和极边的探测要求是一致的，只有为逆序排列我们才能完成规则测试，规则描述为：\n\n所有的顶点需逆序排列，构成凸包顶点序列\n将每个顶点在逆序排列的序列中的前驱顶点称为pre_point,将后继顶点称为next_point\n将由待测试点指向当前凸包点的有向射线称为support line\n将处于support line左边的顶点设置为L，将support line右侧的顶点设置为R\n对任意一个凸包的顶点的前驱和后继分别做to_left_test，将所得的结果命名为当前凸包顶点的状态，例如前驱为L，后继为R则当前凸包顶点的状态为L+R，\n将L+R状态的顶点从凸包集合中去除，并将当前顶点插入到凸包中，插入位置为状态为R+R的顶点的下一个位置\n持续测试待测试顶点\n\n3. 实现算法from common import (    in_triangle_test,     to_left_test,    pattern_in_turn,    colinear_test,    generate_random_point    )import randomimport matplotlib.pyplot as pltimport matplotlibdef draw_polyline(center_point, prev_point, next_point, drawer: plt):    plt.plot([center_point[0], prev_point[0]], [center_point[1], prev_point[1]], color=\"black\", linewidth = 1, label=\" previous point test\")    plt.plot([center_point[0], next_point[0]], [center_point[1], next_point[1]], color=\"black\", linewidth = 1, label=\"next point test\")def draw_convex_polygon(point_set, convex_polygon, drawer: plt):    for index, point in enumerate(point_set):        if index not in convex_polygon:            plt.scatter(point[0], point[1], marker=\"o\", label=\"test point\", color=\"black\")         else:            plt.scatter(point[0], point[1], marker=\"o\", label=\"test point\", color=\"red\")     for index in range(len(convex_polygon) - 1):        point1 = point_set[convex_polygon[index]]        point2 = point_set[convex_polygon[index+1]]        plt.plot([point1[0], point2[0]], [point1[1], point2[1]], color=\"blue\", label=\"convex polygon\")        first_point = point_set[convex_polygon[0]]    last_point = point_set[convex_polygon[-1]]    plt.plot([first_point[0], last_point[0]], [first_point[1], last_point[1]], color=\"blue\", label=\"convex polygon\")    def contruct_convex_polygon(point_set):    # 1. 随机选择三个不共线的点构成凸包        plt.figure(figsize=(8, 8))    plt.ion()    print(f\"point set's size: {len(point_set)}\")    # 点的个数小于3，无法构成凸包    if len(point_set) &lt; 3:        return    convex_polygon = [0, 1]    # 寻找第三个和前两个不共线的点加入到集合中    for i in range(2, len(point_set)):        colinear_test_result = colinear_test(            point_set[convex_polygon[0]],            point_set[convex_polygon[1]],             point_set[i]            )        to_left_test_result = to_left_test(            point_set[convex_polygon[0]],            point_set[convex_polygon[1]],             point_set[i]        )        if False == colinear_test_result and True == to_left_test_result:            print(f\"test colinear: index: {i} false\")            convex_polygon.append(i)            break        print(f\"test colinear: index: {i} true\")        print(f\"initialized convex polygon: {convex_polygon}\\n\")    draw_convex_polygon(point_set, convex_polygon, plt)    # 待测试列表    test_list = [ x for x in list(range(0, len(point_set))) if x not in convex_polygon]    print(test_list)    for test_index, i in enumerate(test_list):        test_point = point_set[i]                patterns = []        for index, j in enumerate(convex_polygon):            plt.clf()            plt.text(0, 0, f\"test point index:{j}\", size=15, color=\"red\")            plt.scatter(test_point[0], test_point[1], s=10, c=\"red\", label=\"test point\")            current_convex_point = point_set[j]            pre_point = []            next_point = []            # 如果是第一个元素，则前驱点为列表的最后一个点，后继为正常后继点            print(f\"convex polygon: {convex_polygon}\")            if index == 0:                print(f\"previous point index: {convex_polygon[-1]}, next point index: {convex_polygon[index + 1]}\")                pre_point = point_set[convex_polygon[-1]]                next_point = point_set[convex_polygon[index + 1]]            # 如果是最后一个元素，则前驱点为正常前驱点，后继为第一个点            elif index == len(convex_polygon) - 1:                print(f\"previous point index: {convex_polygon[index - 1]}, next point index: {convex_polygon[0]}\")                pre_point = point_set[convex_polygon[index - 1]]                next_point = point_set[convex_polygon[0]]            else:                print(f\"previous point index: {j - 1}, next point index: {j + 1}\")                pre_point = point_set[convex_polygon[index - 1]]                next_point = point_set[convex_polygon[index + 1]]            draw_polyline(test_point, pre_point, next_point, plt)            plt.plot([test_point[0], point_set[j][0]], [test_point[1], point_set[j][1]], color=\"red\")            draw_convex_polygon(point_set, convex_polygon, plt)            print(f\"index: {index}\")            pattern_result = pattern_in_turn(pre_point, next_point, [test_point, current_convex_point])            style = dict(size=15, color=\"red\")            # 所有的测试结果            patterns.append(pattern_result)            if 3 == pattern_result:                plt.text(point_set[j][0], point_set[j][1], \"L+L\", **style)            elif 0 == pattern_result:                plt.text(point_set[j][0], point_set[j][1], \"R+R\", **style)            elif 1 == pattern_result:                plt.text(point_set[j][0], point_set[j][1], \"R+L\", **style)            else:                plt.text(point_set[j][0], point_set[j][1], \"L+R\", **style)            plt.title(\"convex polygon construction: incremental construction\")            plt.pause(1)        remove_list = []        point_set_T_index = -1        T_index = -1        S_index = -1        for index, pattern in enumerate(patterns):            if pattern == 0: # T                point_set_T_index = convex_polygon[index]                plt.text(point_set[convex_polygon[index]][0], point_set[convex_polygon[index]][1], \"T\", size=15, color=\"red\")            elif pattern == 3:                S_index = index                plt.text(point_set[convex_polygon[index]][0], point_set[convex_polygon[index]][1], \"S\", size=15, color=\"red\")            elif pattern == 2:                 remove_list.append(convex_polygon[index])                if point_set_T_index != -1:            convex_polygon = [x for x in convex_polygon if x not in remove_list]            convex_polygon.insert(convex_polygon.index(point_set_T_index)+1, i)                plt.title(\"convex polygon construction: incremental construction\")        plt.pause(2)            plt.clf()        draw_convex_polygon(point_set, convex_polygon, plt)        plt.title(\"convex polygon construction: incremental construction\")        plt.pause(1)            plt.ioff()    plt.show()if __name__ == \"__main__\":    point_set = list(zip(*generate_random_point([-3, 3], [-3, 3], 20)))    \"\"\"    point_set = [        [2, 1],        [3, 1],        [2, 2],        [1, 2]    ]    \"\"\"    print(f\"generated point_set: {point_set}\")    contruct_convex_polygon(point_set)\n五、Javis March六、Lower Bound七、Graham Scan: Alogrithm八、Graham Scan: Example九、Graham Scan: Correctness十、Graham Scan: Analysis十一、Divide-And-Conquer十二、Wrap-up","categories":["计算几何"],"tags":["凸包"]},{"title":"Convex Hull In Triangle Test","url":"/2025/06/01/Computational%20Geometry/InTriangleTest/","content":"! pip install matplotlib\nimport matplotlib.pyplot as pltimport random\n\nx_list = [random.uniform(-10, 10) for i in range(-10, 10)]y_list = [random.uniform(-10, 10) for i in range(-10, 10)]for x, y in zip(x_list, y_list):    print(&quot;x: &quot;, x, &quot;, y: &quot;, y)\nx:  4.039168902596996 , y:  -3.3201577215726052\nx:  8.459999626479327 , y:  -0.13736825068833447\nx:  -8.342991923279612 , y:  -7.1629815679156295\nx:  -0.36787835718506656 , y:  -2.448133980966465\nx:  -0.4687168346934456 , y:  3.040681358244493\nx:  -0.28685616430452576 , y:  1.6545115981901226\nx:  9.837035515217035 , y:  3.2942306587502763\nx:  4.5016481434863 , y:  -2.0413345594040377\nx:  1.9318082484926524 , y:  0.18651139391879568\nx:  4.350205767699428 , y:  8.216285604804607\nx:  -9.999493760191719 , y:  4.303036544064035\nx:  -1.7286270125282286 , y:  -1.7820149178647036\nx:  -8.591753322699772 , y:  0.23047966128983788\nx:  5.895396308797414 , y:  -7.628641617043197\nx:  7.509420190645113 , y:  1.003304733473744\nx:  -6.978923639231656 , y:  -2.5683449048039293\nx:  -7.722623283046808 , y:  8.043854497193191\nx:  -5.831863423334667 , y:  4.200704989700856\nx:  5.439294098013551 , y:  -1.479249543919769\nx:  7.151000669383279 , y:  8.93879798676696\nplt.xlim(-10, 10)plt.ylim(-10, 10)plt.figure(figsize=(600, 800))\n&lt;Figure size 43200x57600 with 0 Axes&gt;\n\n&lt;Figure size 43200x57600 with 0 Axes&gt;\nplt.scatter(x_list, y_list, s=10, marker=&quot;o&quot;)plt.show()\n\n寻找极点（穷举）\n选择任意三个不共线的顶点，构成三角形\n对所有顶点执行三角形构造\n判断每一个顶点（除当前判断三角形外）是否在三角形内，如果在三角形内则排除其是极点，如果顶点不被任何一个三角形包围则证明是极点\n\n# 左侧顶点测试, 测试直线point1--&gt;point2def to_left_test(point1, point2, point3)-&gt; bool:    # 叉积刚好是由两个向量所在的平行四边形面积的两倍    value = point1[0] * (point2[1] - point3[1]) + point2[0] * (point3[1] - point1[1]) + point3[0] * (point1[1] - point2[1])    if value &gt; 0:        return True    else:        return False\n测试三个顶点是否共线要判断三个点是否共线，可以通过计算由这三个点形成的向量所构成的行列式的值来实现。如果这三个点共线，那么它们形成的任意两个向量的外积（即叉乘）会是零向量，这等价于这两个向量组成的平行四边形面积为0。对于二维平面上的点来说，这可以通过计算一个特定的2x2矩阵的行列式来完成，或者直接使用一个3x3行列式的方法。\n\n使用行列式判断三点共线给定三个点 $ P_1(x_1, y_1) $，$ P_2(x_2, y_2) $，和 $ P_3(x_3, y_3) $，这三个点共线的条件是：\n\n\\text{det}\n\\begin{pmatrix}\nx_1 & y_1 & 1 \\\\\nx_2 & y_2 & 1 \\\\\nx_3 & y_3 & 1\n\\end{pmatrix}\n= 0这个行列式可以直接展开计算，其结果为：\n\nx_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)如果该表达式的值为 0，则说明这三个点 共线。\ndef colinear_test(point1, point2, point3) -&gt;bool:    value = point1[0] * (point2[1] - point3[1]) + point2[0] * (point3[1] - point1[1]) + point3[0] * (point1[1] - point2[1])    if value == 0:        return True    else:        return Falseif False == colinear_test([1, 0], [0, 1], [1, 1]):    print(&quot;succeed&quot;)else:    print(&quot;error&quot;)\nsucceed\nimport itertoolstriangles = []point_set = []generate_triangle_points_x = []generate_triangle_points_y = []for index, point in enumerate(zip(x_list, y_list)):    if index % 3 == 0:        generate_triangle_points_x.append(point[0])        generate_triangle_points_y.append(point[1])    else:        point_set.append(point)        index += 1points = zip(generate_triangle_points_x, generate_triangle_points_y)for index, triangle in enumerate(itertools.combinations(points, 3)):    triangles.append(triangle)print(&quot;point&#x27;s size: &quot;, len(x_list))print(&quot;triangle point&#x27;s size: &quot;, len(generate_triangle_points_x))print(&quot;point_set point&#x27;s size: &quot;, len(point_set))\npoint&#39;s size:  20\ntriangle point&#39;s size:  7\npoint_set point&#39;s size:  13\ndef draw_triangles_and_points(points, triangles, title):    plt.figure(figsize=(10, 10))    plt.title(title)    # 绘制散点图    for point in points:        plt.scatter(*point)    # 绘制三角形    for triangle in triangles:        point1 = triangle[0]        point2 = triangle[1]        point3 = triangle[2]        plt.plot([point1[0], point2[0]], [point1[1], point2[1]], color=&quot;blue&quot;, linewidth=1)        plt.plot([point1[0], point3[0]], [point1[1], point3[1]], color=&quot;blue&quot;, linewidth=1)        plt.plot([point2[0], point3[0]], [point2[1], point3[1]], color=&quot;blue&quot;, linewidth=1)                plt.show()\n# triangle test Functionsdef test_point_in_triangle(point: list, triangle: list) -&gt; bool:    point_1 = triangle[0]    point_2 = triangle[1]    point_3 = triangle[2]    test_result1 = to_left_test(point_1, point_2, point)    test_result2 = to_left_test(point_2, point_3, point)    test_result3 = to_left_test(point_3, point_1, point)    if test_result1 == test_result2 and \\       test_result2 == test_result3:        return True    else:        return Falsedef test_point_in_triangles(point: list, triangles) -&gt; bool:    for triangle in triangles:        if test_point_in_triangle(point, triangle) == True:            return True        return False\n# Test All Pointdraw_list = []for point in point_set:    test_result = test_point_in_triangles(point, triangles)    draw_list.append(test_result)draw_points = [point for point, is_draw in zip(point_set, draw_list) if True == is_draw]draw_triangles_and_points(draw_points, triangles, &quot;Filtered&quot;)draw_triangles_and_points(point_set, triangles, &quot;Original&quot;)\n\n\n","categories":["计算几何"],"tags":["凸包"]},{"title":"Mitk数据操作和渲染","url":"/2025/05/25/MITK/Mitk%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%B2%E6%9F%93/","content":"Mitk数据操作和渲染一、数据操作1. BaseRenderermitk::BaseRenderer 是mitk的核心渲染组件，\n\n定义了哪些mapper能够被使用\n  enum StandardMapperSlot&#123;  Standard2D = 1,  Standard3D = 2&#125;;\n\n哪些方向可以被渲染\n  enum class ViewDirection&#123;  AXIAL = 0,  SAGITTAL,  CORONAL,  THREE_D&#125;;\n\n所有创建出来的renderer都会被存储到静态变量中，可以直接通过静态方法获取\n\n\nmitk::BaseRenderer中还存储了当前窗口渲染数据时的几何信息，这些信息是后续做数据操作的重要依据，包括缩放、旋转和平移。\nitkGetConstObjectMacro(WorldTimeGeometry, TimeGeometry);itkGetConstObjectMacro(CurrentWorldGeometry, BaseGeometry);itkGetConstObjectMacro(CurrentWorldPlaneGeometry, PlaneGeometry);\n几何信息包括WorldTimeGeometry、CurrentWorldGeometry、CurrentWorldPlaneGeometry\n\n\n2. TimeGeometry\nTimeGeometry中存在着两个重要概念：TimePoint和TimeStep ，其中TimePoint表示在实际扫描过程中从开始已经过去的时间，TimeStep表示在这些TimePoint中的位置。比如在CT扫描过程中每隔300ms扫描一次，那么TimePoint就会是[0, 300, 600 ,900, …]的时间序列，而TimeStep就是这个序列的索引，比如TimeStep=0时，TimePoint=0, TimeStep=1是TimePoint为300ms.\nArbitraryTimeGeometry和ProportionalTimeGeometry 则分别表示了扫描间隔不固定以及扫描间隔固定的两种TimeGeometry。\n需要注意的是在扫描骨头时几乎是用不到这些概念的，因为骨头扫描是静态的无法变化的，多次扫描和单次扫描是相同的效果。对于一些重要的器官扫描比如心脏，是需要多次扫描通过动态信息确定一些疾病的\n但是在MITK中为了处理多种数据，所以存在这种数据结构定义\n\n3. BaseGeometry\nBaseGeometry是TimeGeometry中每个TimeStep对应的一个数据结构，即在特定时间点的扫描数据的几何信息。\n\n4. SliceNavigationController\nSliceNavigationController是TimeGeometry和SlicedGeometry3D及其对应的子类的主要操作类，用于实际控制数据切片、PlaneGeometry的方向以及通知观察者数据变化信息\n所有的Slice的平移、旋转、缩放都应该通过SliceNavigationController来进行完成，这些操作会通过SliceNavigationController来改变对应TimePoint的SlicedGeometry3D并且影响对应的PlaneGeometry。\n\n\n\n所有的PlaneGeometry的旋转、平移、缩放都是通过BaseGeometry完成的，但是这个过程并不是直接的，而是BaseGeometry将变换矩阵存储到了自身的变量m_GeometryTransform中，也就是所有的平面变换信息都会在m_GeometryTransform中进行处理，并在后续的过程中给出一致性的状态信息，例如spacing、offset、transform等等。如果不通过上述方式而旋转手动设置PlaneGeometry的Origin或者旋转PlaneGeometry会在下次动作时被SliceNavigationController自动修复\n\n二、数据渲染在Mitk中数据的渲染过程由mitk::RenderingManager、mitk渲染系统以及vtk的渲染系统组成\n\n1. RenderingManager在mitk中RenderingManager是整个渲染的入口，与vtk不同的是mitk会拦截所有的Qt鼠标事件，然后构建自己的交互系统而不是使用vtkInteractor去控制渲染过程，在MITK2022.10版本中RenderingManager已经变成了单例了，无法手动创建。当需要更新时需要用户手动调用RenderingManager的相关Update方法触发更新，更新分为RequestUpdate和ForceImmediateUpdateAll，RequestUpdate会产生请求更新事件，然后通过检查窗口是否有更新请求来决定更新哪些窗口，而ForceImmediateUpdate方法会立即更新指定窗口，所以尽量使用RequestUpdate方法。\n void RenderingManager::RequestUpdate(vtkRenderWindow *renderWindow)  &#123;    m_RenderWindowList[renderWindow] = RENDERING_REQUESTED;    if (!m_UpdatePending)    &#123;      m_UpdatePending = true;      this-&gt;GenerateRenderingRequestEvent();    &#125;  &#125;void QmitkRenderingManager::GenerateRenderingRequestEvent()&#123;  QApplication::postEvent(this, new QmitkRenderingRequestEvent);&#125;bool QmitkRenderingManager::event(QEvent *event)&#123;  if (event-&gt;type() == (QEvent::Type)QmitkRenderingRequestEvent::RenderingRequest)  &#123;    // Directly process all pending rendering requests    this-&gt;ExecutePendingRequests();    return true;  &#125;  return false;&#125;void RenderingManager::ExecutePendingRequests()  &#123;    m_UpdatePending = false;    // Satisfy all pending update requests    RenderWindowList::const_iterator it;    int i = 0;    for (it = m_RenderWindowList.cbegin(); it != m_RenderWindowList.cend(); ++it, ++i)    &#123;      if (it-&gt;second == RENDERING_REQUESTED)      &#123;        this-&gt;ForceImmediateUpdate(it-&gt;first);      &#125;    &#125;  &#125;void RenderingManager::ForceImmediateUpdate(vtkRenderWindow *renderWindow)  &#123;    if (m_RenderWindowList.find(renderWindow) == m_RenderWindowList.cend())    &#123;      return;    &#125;    m_RenderWindowList[renderWindow] = RENDERING_INACTIVE;    m_UpdatePending = false;    int *size = renderWindow-&gt;GetSize();    if (0 != size[0] &amp;&amp; 0 != size[1])    &#123;      auto *vPR = dynamic_cast&lt;VtkPropRenderer *&gt;(BaseRenderer::GetInstance(renderWindow));      if (vPR)        vPR-&gt;PrepareRender();\t\t\t// 这里已经到vtk的渲染系统了      renderWindow-&gt;Render();    &#125;  &#125;\n2. VtkPropRendererVtkPropRenderer是用于承接用户设置，并将这些设置进行解析，然后将其设置到vtk的相关属性中的一个类。\n首先VtkPropRenderer所做的事情就是解析在DataStorage中存储的所有DataNode中设置的属性，将其更新到对应的vtk渲染属性中，在mitk中用于解析属性设置并生成vtk渲染对象的类为VtkMapper的子类，VtkMapper的输出就是一个vtkProp对象也就是vtk渲染所需要的数据\nint mitk::VtkPropRenderer::Render(mitk::VtkPropRenderer::RenderType type)&#123;  if (type == VtkPropRenderer::Opaque)  &#123;\t\t// 准备渲染队列，    this-&gt;PrepareMapperQueue();    // 执行渲染    this-&gt;PropagateRenderInfoToMappers();  &#125;  // go through the generated list and let the sorted mappers paint  for (auto it = m_MappersMap.cbegin(); it != m_MappersMap.cend(); it++)  &#123;    Mapper *mapper = (*it).second;    mapper-&gt;MitkRender(this, type);  &#125;...  return 1;&#125;//=================================准备渲染队列=================================================================void mitk::VtkPropRenderer::PrepareMapperQueue()&#123;  // Do we have to update the mappers ?  if (m_LastUpdateTime &lt; GetMTime() || m_LastUpdateTime &lt; this-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetMTime())  &#123;\t\t// 遍历所有的数据节点然后调用Update(mitk::DataNode *datatreenode)    Update();  &#125;  else if (m_MapperID &gt;= 1 &amp;&amp; m_MapperID &lt; 6)    Update();  DataStorage::SetOfObjects::ConstPointer allObjects = m_DataStorage-&gt;GetAll();  for (DataStorage::SetOfObjects::ConstIterator it = allObjects-&gt;Begin(); it != allObjects-&gt;End(); ++it)  &#123;    const DataNode::Pointer node = it-&gt;Value();    if (node.IsNull())      continue;    const mitk::Mapper::Pointer mapper = node-&gt;GetMapper(m_MapperID);    bool visible = true;    node-&gt;GetVisibility(visible, this, &quot;visible&quot;);    int layer = 1;    node-&gt;GetIntProperty(&quot;layer&quot;, layer, this);    int nr = (layer &lt;&lt; 16) + mapperNo;    m_MappersMap.insert(std::pair&lt;int, Mapper *&gt;(nr, mapper));    mapperNo++;  &#125;&#125;void mitk::VtkPropRenderer::Update(mitk::DataNode *datatreenode)&#123;  if (datatreenode != nullptr)  &#123;    mitk::Mapper::Pointer mapper = datatreenode-&gt;GetMapper(m_MapperID);    if (mapper.IsNotNull())    &#123;      if (GetCurrentWorldPlaneGeometry()-&gt;IsValid())      &#123;\t\t\t\t// 调用vtkMapper的Update方法更新vtk所需要渲染的内容        mapper-&gt;Update(this);        &#123;          auto *vtkmapper = dynamic_cast&lt;VtkMapper *&gt;(mapper.GetPointer());          if (vtkmapper != nullptr)          &#123;\t\t\t\t\t\t// 更新用户设置的变换矩阵            vtkmapper-&gt;UpdateVtkTransform(this);          &#125;        &#125;      &#125;    &#125;  &#125;&#125;//=================================手动设置vtkProp的属性=================================================================// 更新手动设置的vtkProp的属性信息，这个没用到过void mitk::VtkPropRenderer::PropagateRenderInfoToMappers()&#123;  if (m_VtkRenderInfo == nullptr)    return;  for (const auto &amp;mapEntry : m_MappersMap)  &#123;    auto vtkMapper = dynamic_cast&lt;mitk::VtkMapper*&gt;(mapEntry.second);    if (nullptr != vtkMapper)    &#123;      auto prop = vtkMapper-&gt;GetVtkProp(this);      if (nullptr != prop)        prop-&gt;SetPropertyKeys(m_VtkRenderInfo);    &#125;  &#125;&#125;//=================================执行渲染=================================================================/*这里调用的MitkRenderOpaqueGeometry|MitkRenderTranslucentGeometry|MitkRenderOverlay|MitkRenderVolumetricGeometry的内部就是调用vtk渲染的内部方法了*/void mitk::VtkMapper::MitkRender(mitk::BaseRenderer *renderer, mitk::VtkPropRenderer::RenderType type)&#123;  switch (type)  &#123;    case mitk::VtkPropRenderer::Opaque:      this-&gt;MitkRenderOpaqueGeometry(renderer);      break;    case mitk::VtkPropRenderer::Translucent:      this-&gt;MitkRenderTranslucentGeometry(renderer);      break;    case mitk::VtkPropRenderer::Overlay:      this-&gt;MitkRenderOverlay(renderer);      break;    case mitk::VtkPropRenderer::Volumetric:      this-&gt;MitkRenderVolumetricGeometry(renderer);      break;  &#125;&#125;void mitk::VtkMapper::MitkRenderOpaqueGeometry(BaseRenderer *renderer)&#123;  bool visible = true;  GetDataNode()-&gt;GetVisibility(visible, renderer, &quot;visible&quot;);  if (!visible)    return;  if (this-&gt;GetVtkProp(renderer)-&gt;GetVisibility())  &#123;    GetVtkProp(renderer)-&gt;RenderOpaqueGeometry(renderer-&gt;GetVtkRenderer());  &#125;&#125;\n","categories":["Mitk"]},{"title":"post","url":"/2025/05/25/Others/hexo%20math%20renderer/","content":"数学公式渲染数学公式渲染参照hexo-filter-mathjax\n","categories":["hexo setting"],"tags":["hexo"]}]